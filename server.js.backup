const express = require('express');
const cors = require('cors');
const Database = require('better-sqlite3');
const path = require('path');
const nodemailer = require('nodemailer');
const cron = require('node-cron');
const PythonBridge = require('./python-bridge');
const http = require('http');
const { Server } = require('socket.io');
const fs = require('fs-extra');

const app = express();
const server = http.createServer(app);
const io = new Server(server, {
    cors: {
        origin: "*",
        methods: ["GET", "POST"]
    }
});
const PORT = 3000;

// Veriler klasÃ¶rÃ¼nÃ¼ oluÅŸtur
const dataDir = path.join(__dirname, 'veriler');
const stockFile = path.join(dataDir, 'stok.json');
const salesFile = path.join(dataDir, 'satisGecmisi.json');
const customersFile = path.join(dataDir, 'musteriler.json');
const allDataFile = path.join(dataDir, 'tumVeriler.json');

// Veriler klasÃ¶rÃ¼nÃ¼ oluÅŸtur (eÄŸer yoksa)
fs.ensureDirSync(dataDir);

// SQLite veritabanÄ± dosyasÄ±
const dbPath = path.join(dataDir, 'veritabani.db');
let db;

// Database initialization with better error handling
function initializeDatabase() {
    try {
        // Ensure the database directory exists
        fs.ensureDirSync(path.dirname(dbPath));
        
        // Initialize database connection
        db = new Database(dbPath);
        console.log('âœ… SQLite veritabanÄ±na baÄŸlanÄ±ldÄ±:', dbPath);
        
        // Enable foreign keys and WAL mode for better performance
        db.exec('PRAGMA foreign_keys = ON');
        db.exec('PRAGMA journal_mode = WAL');
        db.exec('PRAGMA synchronous = NORMAL');
        
        // Create tables with proper schema and migration support
        db.exec(`CREATE TABLE IF NOT EXISTS stok (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            barkod TEXT UNIQUE NOT NULL,
            ad TEXT NOT NULL,
            miktar INTEGER DEFAULT 0,
            alisFiyati REAL DEFAULT 0,
            satisFiyati REAL DEFAULT 0,
            kategori TEXT,
            aciklama TEXT,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )`);
        
        db.exec(`CREATE TABLE IF NOT EXISTS satisGecmisi (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            barkod TEXT NOT NULL,
            miktar INTEGER DEFAULT 0,
            fiyat REAL DEFAULT 0,
            alisFiyati REAL DEFAULT 0,
            musteriId TEXT,
            tarih DATETIME DEFAULT CURRENT_TIMESTAMP,
            borc INTEGER DEFAULT 0,
            toplam REAL DEFAULT 0,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )`);
        
        db.exec(`CREATE TABLE IF NOT EXISTS musteriler (
            id TEXT PRIMARY KEY,
            ad TEXT NOT NULL,
            telefon TEXT,
            adres TEXT,
            bakiye REAL DEFAULT 0,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )`);
        
        db.exec(`CREATE TABLE IF NOT EXISTS borclarim (
            id TEXT PRIMARY KEY,
            musteriId TEXT NOT NULL,
            tutar REAL DEFAULT 0,
            aciklama TEXT,
            tarih DATETIME DEFAULT CURRENT_TIMESTAMP,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )`);
        
        // Add missing columns to existing tables if they don't exist
        try {
            db.exec('ALTER TABLE stok ADD COLUMN updated_at DATETIME DEFAULT CURRENT_TIMESTAMP');
        } catch (e) {
            // Column already exists
        }
        
        try {
            db.exec('ALTER TABLE musteriler ADD COLUMN updated_at DATETIME DEFAULT CURRENT_TIMESTAMP');
        } catch (e) {
            // Column already exists
        }
        
        try {
            db.exec('ALTER TABLE satisGecmisi ADD COLUMN created_at DATETIME DEFAULT CURRENT_TIMESTAMP');
        } catch (e) {
            // Column already exists
        }
        
        try {
            db.exec('ALTER TABLE borclarim ADD COLUMN created_at DATETIME DEFAULT CURRENT_TIMESTAMP');
        } catch (e) {
            // Column already exists
        }
        
        console.log('âœ… VeritabanÄ± tablolarÄ± oluÅŸturuldu ve gÃ¼ncellendi');
        
        // Create indexes for better performance
        db.exec('CREATE INDEX IF NOT EXISTS idx_stok_barkod ON stok(barkod)');
        db.exec('CREATE INDEX IF NOT EXISTS idx_stok_updated ON stok(updated_at)');
        db.exec('CREATE INDEX IF NOT EXISTS idx_satis_barkod ON satisGecmisi(barkod)');
        db.exec('CREATE INDEX IF NOT EXISTS idx_satis_tarih ON satisGecmisi(tarih)');
        db.exec('CREATE INDEX IF NOT EXISTS idx_musteri_id ON musteriler(id)');
        db.exec('CREATE INDEX IF NOT EXISTS idx_musteri_updated ON musteriler(updated_at)');
        db.exec('CREATE INDEX IF NOT EXISTS idx_borc_musteri ON borclarim(musteriId)');
        
        console.log('âœ… VeritabanÄ± indeksleri oluÅŸturuldu');
        
        // Verify database integrity
        const tables = db.prepare("SELECT name FROM sqlite_master WHERE type='table'").all();
        console.log('ğŸ“Š Mevcut tablolar:', tables.map(t => t.name));
        
    } catch (err) {
        console.error('âŒ VeritabanÄ± baÅŸlatÄ±lamadÄ±:', err.message);
        process.exit(1);
    }
}

// Initialize database
initializeDatabase();

// WebSocket connection handler with improved data synchronization
io.on('connection', (socket) => {
    console.log('ğŸ”— Client connected:', socket.id);
    
    socket.on('disconnect', () => {
        console.log('âŒ Client disconnected:', socket.id);
    });
    
    // Join a room for data sync
    socket.join('dataSync');
    
    // Send initial data to new client
    socket.emit('connected', {
        message: 'BaÅŸarÄ±yla baÄŸlandÄ±',
        timestamp: new Date().toISOString(),
        socketId: socket.id
    });
    
    // Handle client-side data requests with better error handling
    socket.on('requestData', async () => {
        try {
            console.log('ğŸ“¡ Data request from client:', socket.id);
            
            // Get fresh data from database with transaction and error handling
            const transaction = db.transaction(() => {
                let stokListesi = {};
                let satisGecmisi = [];
                let musteriler = {};
                let borclarim = {};
                
                try {
                    // Check if updated_at column exists before using it
                    const stokColumns = db.prepare("PRAGMA table_info(stok)").all();
                    const hasUpdatedAt = stokColumns.some(col => col.name === 'updated_at');
                    
                    if (hasUpdatedAt) {
                        const stokRows = db.prepare('SELECT * FROM stok ORDER BY updated_at DESC').all();
                        stokRows.forEach(row => { stokListesi[row.barkod] = row; });
                    } else {
                        const stokRows = db.prepare('SELECT * FROM stok ORDER BY id DESC').all();
                        stokRows.forEach(row => { stokListesi[row.barkod] = row; });
                    }
                } catch (e) {
                    console.warn('âš ï¸ Stok tablosu sorgulanÄ±rken hata:', e.message);
                }
                
                try {
                    const satisRows = db.prepare('SELECT * FROM satisGecmisi ORDER BY tarih DESC').all();
                    satisGecmisi = satisRows;
                } catch (e) {
                    console.warn('âš ï¸ SatÄ±ÅŸ geÃ§miÅŸi sorgulanÄ±rken hata:', e.message);
                }
                
                try {
                    const musteriColumns = db.prepare("PRAGMA table_info(musteriler)").all();
                    const musteriHasUpdatedAt = musteriColumns.some(col => col.name === 'updated_at');
                    
                    if (musteriHasUpdatedAt) {
                        const musteriRows = db.prepare('SELECT * FROM musteriler ORDER BY updated_at DESC').all();
                        musteriRows.forEach(row => { musteriler[row.id] = row; });
                    } else {
                        const musteriRows = db.prepare('SELECT * FROM musteriler ORDER BY id DESC').all();
                        musteriRows.forEach(row => { musteriler[row.id] = row; });
                    }
                } catch (e) {
                    console.warn('âš ï¸ MÃ¼ÅŸteriler tablosu sorgulanÄ±rken hata:', e.message);
                }
                
                try {
                    const borcRows = db.prepare('SELECT * FROM borclarim ORDER BY tarih DESC').all();
                    borcRows.forEach(row => { borclarim[row.id] = row; });
                } catch (e) {
                    console.warn('âš ï¸ BorÃ§lar tablosu sorgulanÄ±rken hata:', e.message);
                }
                
                return { stokListesi, satisGecmisi, musteriler, borclarim };
            });
            
            const data = transaction();
            
            socket.emit('dataResponse', {
                success: true,
                data: data,
                timestamp: new Date().toISOString(),
                count: {
                    stok: Object.keys(data.stokListesi).length,
                    satis: data.satisGecmisi.length,
                    musteri: Object.keys(data.musteriler).length,
                    borc: Object.keys(data.borclarim).length
                }
            });
            
            console.log('âœ… Data sent to client:', socket.id);
            
        } catch (error) {
            console.error('âŒ Data request error:', error);
            socket.emit('dataResponse', {
                success: false,
                error: error.message,
                timestamp: new Date().toISOString()
            });
        }
    });
    
    // Handle real-time data updates from clients with validation
    socket.on('dataUpdate', (data) => {
        try {
            console.log('ğŸ“¡ Real-time data update received:', data.type);
            
            // Validate data before broadcasting
            if (!data.type || !data.data) {
                throw new Error('Invalid data update format');
            }
            
            // Validate data structure based on type
            switch (data.type) {
                case 'stok':
                    if (!data.data.barkod || !data.data.ad) {
                        throw new Error('Invalid stok data structure');
                    }
                    break;
                case 'musteri':
                    if (!data.data.id || !data.data.ad) {
                        throw new Error('Invalid musteri data structure');
                    }
                    break;
                case 'satis':
                    if (!data.data.barkod || data.data.miktar === undefined) {
                        throw new Error('Invalid satis data structure');
                    }
                    break;
                case 'borc':
                    if (!data.data.id || !data.data.musteriId) {
                        throw new Error('Invalid borc data structure');
                    }
                    break;
                default:
                    throw new Error('Unknown data type');
            }
            
            // Broadcast to all other clients
            socket.to('dataSync').emit('dataUpdated', {
                type: data.type,
                data: data.data,
                timestamp: new Date().toISOString(),
                source: socket.id
            });
            
            console.log('âœ… Data update broadcasted');
            
        } catch (error) {
            console.error('âŒ Data update error:', error);
            socket.emit('error', { message: error.message });
        }
    });
    
    // Handle client sync requests with database backup
    socket.on('syncRequest', async (data) => {
        try {
            console.log('ğŸ”„ Sync request from client:', socket.id);
            
            // Get fresh data from database with same error handling as requestData
            const transaction = db.transaction(() => {
                let stokListesi = {};
                let satisGecmisi = [];
                let musteriler = {};
                let borclarim = {};
                
                try {
                    const stokColumns = db.prepare("PRAGMA table_info(stok)").all();
                    const hasUpdatedAt = stokColumns.some(col => col.name === 'updated_at');
                    
                    if (hasUpdatedAt) {
                        const stokRows = db.prepare('SELECT * FROM stok ORDER BY updated_at DESC').all();
                        stokRows.forEach(row => { stokListesi[row.barkod] = row; });
                    } else {
                        const stokRows = db.prepare('SELECT * FROM stok ORDER BY id DESC').all();
                        stokRows.forEach(row => { stokListesi[row.barkod] = row; });
                    }
                } catch (e) {
                    console.warn('âš ï¸ Stok tablosu sync sÄ±rasÄ±nda hata:', e.message);
                }
                
                try {
                    const satisRows = db.prepare('SELECT * FROM satisGecmisi ORDER BY tarih DESC').all();
                    satisGecmisi = satisRows;
                } catch (e) {
                    console.warn('âš ï¸ SatÄ±ÅŸ geÃ§miÅŸi sync sÄ±rasÄ±nda hata:', e.message);
                }
                
                try {
                    const musteriColumns = db.prepare("PRAGMA table_info(musteriler)").all();
                    const musteriHasUpdatedAt = musteriColumns.some(col => col.name === 'updated_at');
                    
                    if (musteriHasUpdatedAt) {
                        const musteriRows = db.prepare('SELECT * FROM musteriler ORDER BY updated_at DESC').all();
                        musteriRows.forEach(row => { musteriler[row.id] = row; });
                    } else {
                        const musteriRows = db.prepare('SELECT * FROM musteriler ORDER BY id DESC').all();
                        musteriRows.forEach(row => { musteriler[row.id] = row; });
                    }
                } catch (e) {
                    console.warn('âš ï¸ MÃ¼ÅŸteriler tablosu sync sÄ±rasÄ±nda hata:', e.message);
                }
                
                try {
                    const borcRows = db.prepare('SELECT * FROM borclarim ORDER BY tarih DESC').all();
                    borcRows.forEach(row => { borclarim[row.id] = row; });
                } catch (e) {
                    console.warn('âš ï¸ BorÃ§lar tablosu sync sÄ±rasÄ±nda hata:', e.message);
                }
                
                return { stokListesi, satisGecmisi, musteriler, borclarim };
            });
            
            const freshData = transaction();
            
            // Save to JSON backup
            await fs.writeJson(allDataFile, {
                ...freshData,
                lastSync: new Date().toISOString(),
                syncCount: (await fs.readJson(allDataFile).catch(() => ({ syncCount: 0 }))).syncCount + 1
            });
            
            socket.emit('syncResponse', {
                success: true,
                data: freshData,
                timestamp: new Date().toISOString()
            });
            
            console.log('âœ… Sync completed for client:', socket.id);
            
        } catch (error) {
            console.error('âŒ Sync error:', error);
            socket.emit('syncResponse', {
                success: false,
                error: error.message,
                timestamp: new Date().toISOString()
            });
        }
    });
});

// Veri sanitizasyon fonksiyonlarÄ±
function sanitizeValue(value) {
    if (value === undefined || value === null) return null;
    if (typeof value === 'object') return JSON.stringify(value);
    if (typeof value === 'boolean') return value ? 1 : 0;
    if (typeof value === 'string') return value;
    if (typeof value === 'number') return isNaN(value) ? null : value;
    if (typeof value === 'bigint') return Number(value);
    return String(value);
}

function sanitizeNumber(value) {
    if (value === undefined || value === null || value === '') return 0;
    const num = Number(value);
    return isNaN(num) ? 0 : num;
}

// Middleware
app.use(cors({
    origin: '*',
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With']
}));
app.use(express.json({ limit: '50mb' }));
app.use(express.static('.', {
    index: ['try.html', 'index.html'],
    dotfiles: 'allow'
}));

// API Routes

// GET /api/tum-veriler - TÃ¼m verileri dÃ¶ndÃ¼r
app.get('/api/tum-veriler', async (req, res) => {
    try {
        let stokListesi = {};
        let satisGecmisi = [];
        let musteriler = {};
        let borclarim = {};
        
        try {
            // Check if updated_at column exists before using it
            const stokColumns = db.prepare("PRAGMA table_info(stok)").all();
            const hasUpdatedAt = stokColumns.some(col => col.name === 'updated_at');
            
            if (hasUpdatedAt) {
                const stokRows = db.prepare('SELECT * FROM stok ORDER BY updated_at DESC').all();
                stokRows.forEach(row => { stokListesi[row.barkod] = row; });
            } else {
                const stokRows = db.prepare('SELECT * FROM stok ORDER BY id DESC').all();
                stokRows.forEach(row => { stokListesi[row.barkod] = row; });
            }
        } catch (e) {
            console.warn('âš ï¸ Stok tablosu API sorgulanÄ±rken hata:', e.message);
        }
        
        try {
            const satisRows = db.prepare('SELECT * FROM satisGecmisi ORDER BY tarih DESC').all();
            satisGecmisi = satisRows;
        } catch (e) {
            console.warn('âš ï¸ SatÄ±ÅŸ geÃ§miÅŸi API sorgulanÄ±rken hata:', e.message);
        }
        
        try {
            const musteriColumns = db.prepare("PRAGMA table_info(musteriler)").all();
            const musteriHasUpdatedAt = musteriColumns.some(col => col.name === 'updated_at');
            
            if (musteriHasUpdatedAt) {
                const musteriRows = db.prepare('SELECT * FROM musteriler ORDER BY updated_at DESC').all();
                musteriRows.forEach(row => { musteriler[row.id] = row; });
            } else {
                const musteriRows = db.prepare('SELECT * FROM musteriler ORDER BY id DESC').all();
                musteriRows.forEach(row => { musteriler[row.id] = row; });
            }
        } catch (e) {
            console.warn('âš ï¸ MÃ¼ÅŸteriler tablosu API sorgulanÄ±rken hata:', e.message);
        }
        
        try {
            const borcRows = db.prepare('SELECT * FROM borclarim ORDER BY tarih DESC').all();
            borcRows.forEach(row => { borclarim[row.id] = row; });
        } catch (e) {
            console.warn('âš ï¸ BorÃ§lar tablosu API sorgulanÄ±rken hata:', e.message);
        }
        
        res.json({
            success: true,
            data: { stokListesi, satisGecmisi, musteriler, borclarim },
            message: 'TÃ¼m veriler baÅŸarÄ±yla getirildi',
            timestamp: new Date().toISOString(),
            count: {
                stok: Object.keys(stokListesi).length,
                satis: satisGecmisi.length,
                musteri: Object.keys(musteriler).length,
                borc: Object.keys(borclarim).length
            }
        });
    } catch (error) {
        console.error('Veriler okunurken hata:', error);
        res.status(500).json({
            success: false,
            message: 'Veriler okunurken hata oluÅŸtu',
            error: error.message,
            timestamp: new Date().toISOString()
        });
    }
});

// POST /api/tum-veriler - TÃ¼m verileri kaydet
app.post('/api/tum-veriler', async (req, res) => {
    try {
        const { stokListesi, satisGecmisi, musteriler, borclarim } = req.body;
        
        // Validate required data
        if (!stokListesi || !satisGecmisi || !musteriler) {
            return res.status(400).json({
                success: false,
                message: 'Eksik veri: stokListesi, satisGecmisi ve musteriler gerekli'
            });
        }
        
        // Validate data structure and check for duplicates
        const validationErrors = [];
        
        // Check for duplicate barkod in stokListesi
        const barkodSet = new Set();
        for (const barkod in stokListesi) {
            const urun = stokListesi[barkod];
            if (urun && urun.barkod) {
                if (barkodSet.has(urun.barkod)) {
                    validationErrors.push(`Duplicate barkod found: ${urun.barkod}`);
                } else {
                    barkodSet.add(urun.barkod);
                }
            }
        }
        
        // Check for duplicate musteri IDs
        const musteriIdSet = new Set();
        for (const id in musteriler) {
            const musteri = musteriler[id];
            if (musteri && musteri.id) {
                if (musteriIdSet.has(musteri.id)) {
                    validationErrors.push(`Duplicate musteri ID found: ${musteri.id}`);
                } else {
                    musteriIdSet.add(musteri.id);
                }
            }
        }
        
        // Check for duplicate borc IDs if borclarim exists
        if (borclarim) {
            const borcIdSet = new Set();
            for (const id in borclarim) {
                const borc = borclarim[id];
                if (borc && borc.id) {
                    if (borcIdSet.has(borc.id)) {
                        validationErrors.push(`Duplicate borc ID found: ${borc.id}`);
                    } else {
                        borcIdSet.add(borc.id);
                    }
                }
            }
        }
        
        if (validationErrors.length > 0) {
            console.warn('âš ï¸ Data validation warnings:', validationErrors);
            // Continue processing but log warnings
        }
        
        // Use transaction for data consistency
        const transaction = db.transaction(() => {
            try {
                // Clear existing data
                db.prepare('DELETE FROM stok').run();
                db.prepare('DELETE FROM satisGecmisi').run();
                db.prepare('DELETE FROM musteriler').run();
                if (borclarim) {
                    db.prepare('DELETE FROM borclarim').run();
                }
                
                // Insert stok data with duplicate handling
                const insertStok = db.prepare(`INSERT INTO stok (barkod, ad, miktar, alisFiyati, satisFiyati, kategori, aciklama, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)`);
                const updateStok = db.prepare(`UPDATE stok SET ad = ?, miktar = ?, alisFiyati = ?, satisFiyati = ?, kategori = ?, aciklama = ?, updated_at = CURRENT_TIMESTAMP WHERE barkod = ?`);
                
                // Track processed barkod values to avoid duplicates
                const processedBarkod = new Set();
                
                for (const barkod in stokListesi) {
                    const urun = stokListesi[barkod];
                    if (urun && urun.barkod) {
                        const cleanBarkod = sanitizeValue(urun.barkod);
                        
                        // Skip if we've already processed this barkod
                        if (processedBarkod.has(cleanBarkod)) {
                            console.log(`âš ï¸ Duplicate barkod skipped: ${cleanBarkod}`);
                            continue;
                        }
                        
                        processedBarkod.add(cleanBarkod);
                        
                        try {
                            insertStok.run(
                                cleanBarkod,
                                sanitizeValue(urun.ad),
                                sanitizeNumber(urun.miktar),
                                sanitizeNumber(urun.alisFiyati),
                                sanitizeNumber(urun.satisFiyati),
                                sanitizeValue(urun.kategori),
                                sanitizeValue(urun.aciklama)
                            );
                        } catch (error) {
                            if (error.code === 'SQLITE_CONSTRAINT_UNIQUE') {
                                // If insert fails due to UNIQUE constraint, try to update instead
                                console.log(`ğŸ”„ Updating existing stok with barkod: ${cleanBarkod}`);
                                updateStok.run(
                                    sanitizeValue(urun.ad),
                                    sanitizeNumber(urun.miktar),
                                    sanitizeNumber(urun.alisFiyati),
                                    sanitizeNumber(urun.satisFiyati),
                                    sanitizeValue(urun.kategori),
                                    sanitizeValue(urun.aciklama),
                                    cleanBarkod
                                );
                            } else {
                                throw error;
                            }
                        }
                    }
                }
                
                // Insert satis data
                const insertSatis = db.prepare(`INSERT INTO satisGecmisi (barkod, miktar, fiyat, alisFiyati, musteriId, tarih, borc, toplam, created_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)`);
                for (const satis of satisGecmisi) {
                    if (satis && satis.barkod) {
                        insertSatis.run(
                            sanitizeValue(satis.barkod),
                            sanitizeNumber(satis.miktar),
                            sanitizeNumber(satis.fiyat),
                            sanitizeNumber(satis.alisFiyati),
                            sanitizeValue(satis.musteriId),
                            sanitizeValue(satis.tarih),
                            sanitizeNumber(satis.borc),
                            sanitizeNumber(satis.toplam)
                        );
                    }
                }
                
                // Insert musteri data with duplicate handling
                const insertMusteri = db.prepare(`INSERT INTO musteriler (id, ad, telefon, adres, bakiye, created_at, updated_at) VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)`);
                const updateMusteri = db.prepare(`UPDATE musteriler SET ad = ?, telefon = ?, adres = ?, bakiye = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?`);
                
                // Track processed musteri IDs to avoid duplicates
                const processedMusteriId = new Set();
                
                for (const id in musteriler) {
                    const musteri = musteriler[id];
                    if (musteri && musteri.id) {
                        const cleanId = sanitizeValue(musteri.id);
                        
                        // Skip if we've already processed this musteri ID
                        if (processedMusteriId.has(cleanId)) {
                            console.log(`âš ï¸ Duplicate musteri ID skipped: ${cleanId}`);
                            continue;
                        }
                        
                        processedMusteriId.add(cleanId);
                        
                        try {
                            insertMusteri.run(
                                cleanId,
                                sanitizeValue(musteri.ad),
                                sanitizeValue(musteri.telefon),
                                sanitizeValue(musteri.adres),
                                sanitizeNumber(musteri.bakiye)
                            );
                        } catch (error) {
                            if (error.code === 'SQLITE_CONSTRAINT_UNIQUE') {
                                // If insert fails due to UNIQUE constraint, try to update instead
                                console.log(`ğŸ”„ Updating existing musteri with ID: ${cleanId}`);
                                updateMusteri.run(
                                    sanitizeValue(musteri.ad),
                                    sanitizeValue(musteri.telefon),
                                    sanitizeValue(musteri.adres),
                                    sanitizeNumber(musteri.bakiye),
                                    cleanId
                                );
                            } else {
                                throw error;
                            }
                        }
                    }
                }
                
                // Insert borc data if provided with duplicate handling
                if (borclarim) {
                    const insertBorc = db.prepare(`INSERT INTO borclarim (id, musteriId, tutar, aciklama, tarih, created_at) VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)`);
                    const updateBorc = db.prepare(`UPDATE borclarim SET musteriId = ?, tutar = ?, aciklama = ?, tarih = ? WHERE id = ?`);
                    
                    // Track processed borc IDs to avoid duplicates
                    const processedBorcId = new Set();
                    
                    for (const id in borclarim) {
                        const borc = borclarim[id];
                        if (borc && borc.id) {
                            const cleanId = sanitizeValue(borc.id);
                            
                            // Skip if we've already processed this borc ID
                            if (processedBorcId.has(cleanId)) {
                                console.log(`âš ï¸ Duplicate borc ID skipped: ${cleanId}`);
                                continue;
                            }
                            
                            processedBorcId.add(cleanId);
                            
                            try {
                                insertBorc.run(
                                    cleanId,
                                    sanitizeValue(borc.musteriId),
                                    sanitizeNumber(borc.tutar),
                                    sanitizeValue(borc.aciklama),
                                    sanitizeValue(borc.tarih)
                                );
                            } catch (error) {
                                if (error.code === 'SQLITE_CONSTRAINT_UNIQUE') {
                                    // If insert fails due to UNIQUE constraint, try to update instead
                                    console.log(`ğŸ”„ Updating existing borc with ID: ${cleanId}`);
                                    updateBorc.run(
                                        sanitizeValue(borc.musteriId),
                                        sanitizeNumber(borc.tutar),
                                        sanitizeValue(borc.aciklama),
                                        sanitizeValue(borc.tarih),
                                        cleanId
                                    );
                                } else {
                                    throw error;
                                }
                            }
                        }
                    }
                }
                
                // Save backup to JSON file
                const backupData = {
                    stokListesi,
                    satisGecmisi,
                    musteriler,
                    borclarim: borclarim || {},
                    lastSync: new Date().toISOString(),
                    syncCount: 1
                };
                
                fs.writeJsonSync(allDataFile, backupData);
                
                return {
                    stokCount: Object.keys(stokListesi).length,
                    satisCount: satisGecmisi.length,
                    musteriCount: Object.keys(musteriler).length,
                    borcCount: borclarim ? Object.keys(borclarim).length : 0
                };
                
            } catch (error) {
                console.error('Transaction error:', error);
                if (error.code === 'SQLITE_CONSTRAINT_UNIQUE') {
                    console.error('âŒ UNIQUE constraint violation detected. This usually means duplicate data was provided.');
                    console.error('ğŸ“‹ Check your input data for duplicate barkod, musteri ID, or borc ID values.');
                }
                throw error;
            }
        });
        
        const result = transaction();
        
        // Notify all connected clients
        io.to('dataSync').emit('dataUpdated', {
            type: 'bulk-sync',
            timestamp: new Date().toISOString(),
            stats: result
        });
        
        console.log(`âœ… Toplu senkronizasyon tamamlandÄ± - Stok: ${result.stokCount}, SatÄ±ÅŸ: ${result.satisCount}, MÃ¼ÅŸteri: ${result.musteriCount}, BorÃ§: ${result.borcCount}`);

        res.json({
            success: true,
            message: 'TÃ¼m veriler baÅŸarÄ±yla kaydedildi',
            stats: result
        });
        
    } catch (error) {
        console.error('âŒ Veriler kaydedilirken hata:', error);
        res.status(500).json({
            success: false,
            message: 'Veriler kaydedilirken hata oluÅŸtu',
            error: error.message
        });
    }
});

// POST /api/stok-ekle - Tek Ã¼rÃ¼n ekle
app.post('/api/stok-ekle', async (req, res) => {
    try {
        const urun = req.body;
        console.log('ğŸ“¦ Yeni Ã¼rÃ¼n ekleniyor:', urun.barkod, urun.ad);
        
        // Check if updated_at column exists
        const stokColumns = db.prepare("PRAGMA table_info(stok)").all();
        const hasUpdatedAt = stokColumns.some(col => col.name === 'updated_at');
        
        let insertStok;
        if (hasUpdatedAt) {
            insertStok = db.prepare(`INSERT OR REPLACE INTO stok (barkod, ad, miktar, alisFiyati, satisFiyati, kategori, aciklama, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)`);
        } else {
            insertStok = db.prepare(`INSERT OR REPLACE INTO stok (barkod, ad, miktar, alisFiyati, satisFiyati, kategori, aciklama) VALUES (?, ?, ?, ?, ?, ?, ?)`);
        }
        
        const result = insertStok.run(
            sanitizeValue(urun.barkod),
            sanitizeValue(urun.ad),
            sanitizeNumber(urun.miktar),
            sanitizeNumber(urun.alisFiyati),
            sanitizeNumber(urun.satisFiyati),
            sanitizeValue(urun.kategori),
            sanitizeValue(urun.aciklama)
        );
        
        // Real-time sync to all clients
        io.to('dataSync').emit('dataUpdated', {
            type: 'stok-add',
            data: urun,
            timestamp: new Date().toISOString()
        });
        
        res.json({ 
            success: true, 
            message: 'ÃœrÃ¼n baÅŸarÄ±yla eklendi', 
            data: urun,
            timestamp: new Date().toISOString()
        });
        
    } catch (error) {
        console.error('âŒ ÃœrÃ¼n eklenirken hata:', error);
        res.status(500).json({ 
            success: false, 
            message: 'ÃœrÃ¼n eklenirken hata', 
            error: error.message,
            timestamp: new Date().toISOString()
        });
    }
});

// PUT /api/stok-guncelle - ÃœrÃ¼n gÃ¼ncelle
app.put('/api/stok-guncelle', async (req, res) => {
    try {
        const urun = req.body;
        console.log('ğŸ”„ ÃœrÃ¼n gÃ¼ncelleniyor:', urun.barkod);
        
        // Check if updated_at column exists
        const stokColumns = db.prepare("PRAGMA table_info(stok)").all();
        const hasUpdatedAt = stokColumns.some(col => col.name === 'updated_at');
        
        let updateStok;
        if (hasUpdatedAt) {
            updateStok = db.prepare(`UPDATE stok SET ad = ?, miktar = ?, alisFiyati = ?, satisFiyati = ?, kategori = ?, aciklama = ?, updated_at = CURRENT_TIMESTAMP WHERE barkod = ?`);
        } else {
            updateStok = db.prepare(`UPDATE stok SET ad = ?, miktar = ?, alisFiyati = ?, satisFiyati = ?, kategori = ?, aciklama = ? WHERE barkod = ?`);
        }
        
        const result = updateStok.run(
            sanitizeValue(urun.ad),
            sanitizeNumber(urun.miktar),
            sanitizeNumber(urun.alisFiyati),
            sanitizeNumber(urun.satisFiyati),
            sanitizeValue(urun.kategori),
            sanitizeValue(urun.aciklama),
            sanitizeValue(urun.barkod)
        );
        
        if (result.changes > 0) {
            // Real-time sync to all clients
            io.to('dataSync').emit('dataUpdated', {
                type: 'stok-update',
                data: urun,
                timestamp: new Date().toISOString()
            });
            
            res.json({ 
                success: true, 
                message: 'ÃœrÃ¼n baÅŸarÄ±yla gÃ¼ncellendi', 
                data: urun,
                timestamp: new Date().toISOString()
            });
        } else {
            res.status(404).json({ success: false, message: 'ÃœrÃ¼n bulunamadÄ±' });
        }
        
    } catch (error) {
        console.error('âŒ ÃœrÃ¼n gÃ¼ncellenirken hata:', error);
        res.status(500).json({ success: false, message: 'ÃœrÃ¼n gÃ¼ncellenirken hata', error: error.message });
    }
});

// DELETE /api/stok-sil/:barkod - ÃœrÃ¼n sil
app.delete('/api/stok-sil/:barkod', async (req, res) => {
    try {
        const { barkod } = req.params;
        console.log('ğŸ—‘ï¸ ÃœrÃ¼n siliniyor:', barkod);
        
        const deleteStok = db.prepare('DELETE FROM stok WHERE barkod = ?');
        const result = deleteStok.run(sanitizeValue(barkod));
        
        if (result.changes > 0) {
            // Real-time sync to all clients
            io.to('dataSync').emit('dataUpdated', {
                type: 'stok-delete',
                data: { barkod },
                timestamp: new Date().toISOString()
            });
            
            res.json({ success: true, message: 'ÃœrÃ¼n baÅŸarÄ±yla silindi' });
        } else {
            res.status(404).json({ success: false, message: 'ÃœrÃ¼n bulunamadÄ±' });
        }
        
    } catch (error) {
        console.error('âŒ ÃœrÃ¼n silinirken hata:', error);
        res.status(500).json({ success: false, message: 'ÃœrÃ¼n silinirken hata', error: error.message });
    }
});

// POST /api/satis-ekle - SatÄ±ÅŸ kaydet
app.post('/api/satis-ekle', async (req, res) => {
    try {
        const satis = req.body;
        console.log('ğŸ’° Yeni satÄ±ÅŸ kaydediliyor:', satis.barkod);
        
        const insertSatis = db.prepare(`INSERT INTO satisGecmisi (barkod, miktar, fiyat, alisFiyati, musteriId, tarih, borc, toplam) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`);
        insertSatis.run(
            sanitizeValue(satis.barkod),
            sanitizeNumber(satis.miktar),
            sanitizeNumber(satis.fiyat),
            sanitizeNumber(satis.alisFiyati),
            sanitizeValue(satis.musteriId),
            sanitizeValue(satis.tarih),
            sanitizeNumber(satis.borc),
            sanitizeNumber(satis.toplam)
        );
        
        // Stok gÃ¼ncelle
        if (satis.barkod && satis.miktar) {
            const updateStok = db.prepare('UPDATE stok SET miktar = miktar - ? WHERE barkod = ?');
            updateStok.run(sanitizeNumber(satis.miktar), sanitizeValue(satis.barkod));
        }
        
        // Real-time sync to all clients
        io.to('dataSync').emit('dataUpdated', {
            type: 'satis-add',
            data: satis,
            timestamp: new Date().toISOString()
        });
        
        res.json({ success: true, message: 'SatÄ±ÅŸ baÅŸarÄ±yla kaydedildi', data: satis });
        
    } catch (error) {
        console.error('âŒ SatÄ±ÅŸ kaydedilirken hata:', error);
        res.status(500).json({ success: false, message: 'SatÄ±ÅŸ kaydedilirken hata', error: error.message });
    }
});

// POST /api/musteri-ekle - MÃ¼ÅŸteri ekle
app.post('/api/musteri-ekle', async (req, res) => {
    try {
        const musteri = req.body;
        console.log('ğŸ‘¥ Yeni mÃ¼ÅŸteri ekleniyor:', musteri.ad);
        
        // Check if updated_at column exists
        const musteriColumns = db.prepare("PRAGMA table_info(musteriler)").all();
        const hasUpdatedAt = musteriColumns.some(col => col.name === 'updated_at');
        
        let insertMusteri;
        if (hasUpdatedAt) {
            insertMusteri = db.prepare(`INSERT OR REPLACE INTO musteriler (id, ad, telefon, adres, bakiye, created_at, updated_at) VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)`);
        } else {
            insertMusteri = db.prepare(`INSERT OR REPLACE INTO musteriler (id, ad, telefon, adres, bakiye) VALUES (?, ?, ?, ?, ?)`);
        }
        
        const result = insertMusteri.run(
            sanitizeValue(musteri.id),
            sanitizeValue(musteri.ad),
            sanitizeValue(musteri.telefon),
            sanitizeValue(musteri.adres),
            sanitizeNumber(musteri.bakiye)
        );
        
        // Real-time sync to all clients
        io.to('dataSync').emit('dataUpdated', {
            type: 'musteri-add',
            data: musteri,
            timestamp: new Date().toISOString()
        });
        
        res.json({ 
            success: true, 
            message: 'MÃ¼ÅŸteri baÅŸarÄ±yla eklendi', 
            data: musteri,
            timestamp: new Date().toISOString()
        });
        
    } catch (error) {
        console.error('âŒ MÃ¼ÅŸteri eklenirken hata:', error);
        res.status(500).json({ 
            success: false, 
            message: 'MÃ¼ÅŸteri eklenirken hata', 
            error: error.message,
            timestamp: new Date().toISOString()
        });
    }
});

// Eski endpoint'ler (geriye uyumluluk iÃ§in)
app.get('/urunler', async (req, res) => {
    try {
        const rows = db.prepare('SELECT * FROM stok').all();
        let stokData = {};
        rows.forEach(row => { stokData[row.barkod] = row; });
        res.json({
            success: true,
            data: stokData,
            message: 'ÃœrÃ¼nler baÅŸarÄ±yla getirildi'
        });
    } catch (error) {
        console.error('ÃœrÃ¼nler okunurken hata:', error);
        res.status(500).json({
            success: false,
            message: 'ÃœrÃ¼nler okunurken hata oluÅŸtu',
            error: error.message
        });
    }
});

app.post('/urunler', async (req, res) => {
    try {
        const { stokListesi } = req.body;
        if (!stokListesi || typeof stokListesi !== 'object') {
            return res.status(400).json({
                               success: false,
                message: 'GeÃ§ersiz veri formatÄ±. stokListesi objesi bekleniyor.'
            });
        }
        
        const transaction = db.transaction(() => {
            db.prepare('DELETE FROM stok').run();
            const insertStok = db.prepare(`INSERT INTO stok (barkod, ad, miktar, alisFiyati, satisFiyati, kategori, aciklama) VALUES (?, ?, ?, ?, ?, ?, ?)`);
            for (const barkod in stokListesi) {
                const urun = stokListesi[barkod];
                insertStok.run(
                    sanitizeValue(urun.barkod),
                    sanitizeValue(urun.ad),
                    sanitizeNumber(urun.miktar),
                    sanitizeNumber(urun.alisFiyati),
                    sanitizeNumber(urun.satisFiyati),
                    sanitizeValue(urun.kategori),
                    sanitizeValue(urun.aciklama)
                );
            }
        });
        
        transaction();
        
        res.json({
            success: true,
            message: 'ÃœrÃ¼nler baÅŸarÄ±yla kaydedildi',
            count: Object.keys(stokListesi).length
        });
    } catch (error) {
        console.error('ÃœrÃ¼nler kaydedilirken hata:', error);
        res.status(500).json({
            success: false,
            message: 'ÃœrÃ¼nler kaydedilirken hata oluÅŸtu',
            error: error.message
        });
    }
});

// Ana sayfa iÃ§in HTML dosyasÄ±nÄ± serve et
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'Try.html'));
});

// Hata yakalama middleware
app.use((error, req, res, next) => {
    console.error('Sunucu hatasÄ±:', error);
    res.status(500).json({
        success: false,
        message: 'Sunucu hatasÄ± oluÅŸtu',
        error: error.message
    });
});

// Python Bridge API Endpoints
const pythonBridge = new PythonBridge();

// POST /api/python/backup - VeritabanÄ± yedekleme
app.post('/api/python/backup', async (req, res) => {
    try {
        const result = await pythonBridge.backupDatabase();
        res.json(result);
    } catch (error) {
        res.status(500).json({
            success: false,
            message: 'Python backup hatasÄ±',
            error: error.message
        });
    }
});

// GET /api/python/analyze - Veri analizi
app.get('/api/python/analyze', async (req, res) => {
    try {
        const result = await pythonBridge.analyzeData();
        res.json(result);
    } catch (error) {
        res.status(500).json({
            success: false,
            message: 'Python analiz hatasÄ±',
            error: error.message
        });
    }
});

// GET /api/python/report/:type - Rapor oluÅŸturma
app.get('/api/python/report/:type', async (req, res) => {
    try {
        const reportType = req.params.type || 'monthly';
        const result = await pythonBridge.generateReport(reportType);
        res.json(result);
    } catch (error) {
        res.status(500).json({
            success: false,
            message: 'Python rapor hatasÄ±',
            error: error.message
        });
    }
});

// 404 handler
app.use((req, res) => {
    res.status(404).json({
        success: false,
        message: 'Endpoint bulunamadÄ±'
    });
});

// Yedek dosyasÄ±nÄ± mail ile gÃ¶nder
async function sendBackupMail() {
    try {
        // TÃ¼m verileri veritabanÄ±ndan Ã§ek
        let allData = {};
        
        const stokRows = db.prepare('SELECT * FROM stok').all();
        const satisRows = db.prepare('SELECT * FROM satisGecmisi').all();
        const musteriRows = db.prepare('SELECT * FROM musteriler').all();
        const borcRows = db.prepare('SELECT * FROM borclarim').all();
        
        let stokListesi = {};
        let satisGecmisi = [];
        let musteriler = {};
        let borclarim = {};
        
        stokRows.forEach(row => { stokListesi[row.barkod] = row; });
        satisGecmisi = satisRows;
        musteriRows.forEach(row => { musteriler[row.id] = row; });
        borcRows.forEach(row => { borclarim[row.id] = row; });
        
        allData = { stokListesi, satisGecmisi, musteriler, borclarim };
        const transporter = nodemailer.createTransport({
            service: 'gmail',
            auth: {
                user: 'yedek@example.com', // GÃ–NDEREN MAIL
                pass: 'uygunuygulamasifresi' // Uygulama ÅŸifresi veya app password
            }
        });
        await transporter.sendMail({
            from: 'yedek@example.com',
            to: 'yedek@example.com', // ALICI MAIL
            subject: `GÃ¼nlÃ¼k Yedek - ${new Date().toLocaleDateString('tr-TR')}`,
            text: 'GÃ¼nlÃ¼k otomatik yedek dosyasÄ± ektedir.',
            attachments: [
                {
                    filename: `yedek_${new Date().toISOString().replace(/:/g, '-')}.json`,
                    content: JSON.stringify(allData, null, 2)
                }
            ]
        });
        console.log('Yedek maili gÃ¶nderildi.');
    } catch (error) {
        console.error('Yedek maili gÃ¶nderilemedi:', error);
    }
}

// Her gÃ¼n gece 23:59'da yedek maili gÃ¶nder
cron.schedule('59 23 * * *', () => {
    sendBackupMail();
});

// Network bilgilerini getir endpoint
app.get('/api/network-info', (req, res) => {
    try {
        const os = require('os');
        const networkInterfaces = os.networkInterfaces();
        const addresses = [];
        
        Object.keys(networkInterfaces).forEach(interfaceName => {
            const interfaces = networkInterfaces[interfaceName];
            interfaces.forEach(iface => {
                if (iface.family === 'IPv4' && !iface.internal) {
                    addresses.push(iface.address);
                }
            });
        });
        
        res.json({
            success: true,
            addresses: addresses,
            hostname: os.hostname(),
            port: PORT,
            timestamp: new Date().toISOString()
        });
        
    } catch (error) {
        res.status(500).json({
            success: false,
            message: 'Network bilgileri alÄ±namadÄ±',
            error: error.message
        });
    }
});

// VeritabanÄ±nÄ± yeniden baÅŸlat endpoint
app.post('/api/reset-database', (req, res) => {
    try {
        console.log('ğŸ”„ VeritabanÄ± sÄ±fÄ±rlanÄ±yor...');
        
        // VeritabanÄ±nÄ± kapat
        if (db) {
            db.close();
        }
        
        // VeritabanÄ± dosyasÄ±nÄ± sil
        if (fs.existsSync(dbPath)) {
            fs.unlinkSync(dbPath);
            console.log('ğŸ—‘ï¸ Eski veritabanÄ± dosyasÄ± silindi');
        }
        
        // Yeni veritabanÄ± oluÅŸtur
        initializeDatabase();
        console.log('âœ… Yeni veritabanÄ± oluÅŸturuldu');
        
        // TablolarÄ± yeniden oluÅŸtur
        // initializeDatabase() already handles this, but calling it again for clarity
        // initializeDatabase(); 
        console.log('ğŸ“‹ Tablolar yeniden oluÅŸturuldu');
        
        res.json({
            success: true,
            message: 'VeritabanÄ± baÅŸarÄ±yla sÄ±fÄ±rlandÄ± ve yeniden oluÅŸturuldu',
            timestamp: new Date().toISOString()
        });
        
    } catch (error) {
        console.error('âŒ VeritabanÄ± sÄ±fÄ±rlama hatasÄ±:', error);
        res.status(500).json({
            success: false,
            message: 'VeritabanÄ± sÄ±fÄ±rlanamadÄ±',
            error: error.message
        });
    }
});

// Database durumunu kontrol et endpoint
app.get('/api/database-status', (req, res) => {
    try {
        const stats = fs.statSync(dbPath);
        
        // Basit bir test sorgusu
        const testQuery = db.prepare('SELECT COUNT(*) as count FROM stok').get();
        
        res.json({
            success: true,
            database: {
                exists: true,
                size: stats.size,
                created: stats.birthtime,
                modified: stats.mtime
            },
            tables: {
                stok_count: testQuery.count
            },
            message: 'VeritabanÄ± Ã§alÄ±ÅŸÄ±yor'
        });
        
    } catch (error) {
        res.status(500).json({
            success: false,
            message: 'VeritabanÄ± eriÅŸim hatasÄ±',
            error: error.message
        });
    }
});

// Ana sayfa redirect'i
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'try.html'));
});

// QR Connection sayfasÄ±nÄ± serve et
app.get('/qr', (req, res) => {
    res.sendFile(path.join(__dirname, 'qr-connection.html'));
});

// Static file serving iÃ§in ek route'lar
app.get('/try.html', (req, res) => {
    res.sendFile(path.join(__dirname, 'try.html'));
});

// CORS preflight iÃ§in OPTIONS handler
app.options('*', (req, res) => {
    res.header('Access-Control-Allow-Origin', '*');
    res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
    res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Requested-With');
    res.sendStatus(200);
});

// Debug endpoint - baÄŸlantÄ± testi
app.get('/api/test', (req, res) => {
    try {
        // Database connection test
        const dbTest = db.prepare('SELECT 1 as test').get();
        
        // Table structure test
        const stokColumns = db.prepare("PRAGMA table_info(stok)").all();
        const musteriColumns = db.prepare("PRAGMA table_info(musteriler)").all();
        
        // Data count test
        const stokCount = db.prepare('SELECT COUNT(*) as count FROM stok').get();
        const musteriCount = db.prepare('SELECT COUNT(*) as count FROM musteriler').get();
        const satisCount = db.prepare('SELECT COUNT(*) as count FROM satisGecmisi').get();
        const borcCount = db.prepare('SELECT COUNT(*) as count FROM borclarim').get();
        
        res.json({
            success: true,
            message: 'API Ã§alÄ±ÅŸÄ±yor',
            timestamp: new Date().toISOString(),
            database: {
                connected: true,
                test: dbTest.test
            },
            tables: {
                stok: {
                    exists: stokColumns.length > 0,
                    columns: stokColumns.map(col => col.name),
                    count: stokCount.count,
                    hasUpdatedAt: stokColumns.some(col => col.name === 'updated_at')
                },
                musteriler: {
                    exists: musteriColumns.length > 0,
                    columns: musteriColumns.map(col => col.name),
                    count: musteriCount.count,
                    hasUpdatedAt: musteriColumns.some(col => col.name === 'updated_at')
                },
                satisGecmisi: {
                    count: satisCount.count
                },
                borclarim: {
                    count: borcCount.count
                }
            },
            socket: {
                connected: io.engine.clientsCount,
                rooms: Object.keys(io.sockets.adapter.rooms)
            }
        });
        
    } catch (error) {
        console.error('âŒ Test endpoint hatasÄ±:', error);
        res.status(500).json({
            success: false,
            message: 'Test baÅŸarÄ±sÄ±z',
            error: error.message,
            timestamp: new Date().toISOString()
        });
    }
});

// Comprehensive debug endpoint
app.get('/api/debug', async (req, res) => {
    try {
        const debugInfo = {
            server: {
                status: 'running',
                timestamp: new Date().toISOString(),
                uptime: process.uptime(),
                memory: process.memoryUsage(),
                version: process.version,
                platform: process.platform
            },
            database: {
                status: db ? 'connected' : 'disconnected',
                path: dbPath,
                tables: []
            },
            files: {
                dataDir: dataDir,
                stockFile: stockFile,
                salesFile: salesFile,
                customersFile: customersFile,
                allDataFile: allDataFile
            },
            connections: {
                socketConnections: io.engine.clientsCount,
                activeConnections: Object.keys(io.sockets.sockets).length
            }
        };

        // Get database table info
        if (db) {
            try {
                const tables = ['stok', 'satisGecmisi', 'musteriler', 'borclarim'];
                for (const table of tables) {
                    try {
                        const count = db.prepare(`SELECT COUNT(*) as count FROM ${table}`).get();
                        debugInfo.database.tables.push({
                            name: table,
                            count: count.count,
                            status: 'ok'
                        });
                    } catch (error) {
                        debugInfo.database.tables.push({
                            name: table,
                            count: 0,
                            status: 'error',
                            error: error.message
                        });
                    }
                }
            } catch (error) {
                debugInfo.database.error = error.message;
            }
        }

        // Check file system
        try {
            debugInfo.files.stockExists = fs.existsSync(stockFile);
            debugInfo.files.salesExists = fs.existsSync(salesFile);
            debugInfo.files.customersExists = fs.existsSync(customersFile);
            debugInfo.files.allDataExists = fs.existsSync(allDataFile);
        } catch (error) {
            debugInfo.files.error = error.message;
        }

        res.json({
            success: true,
            debug: debugInfo
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message,
            debug: {
                server: {
                    status: 'error',
                    timestamp: new Date().toISOString()
                }
            }
        });
    }
});

// Database status endpoint
app.get('/api/database-status', (req, res) => {
    try {
        if (!db) {
            return res.json({
                success: false,
                status: 'Database not initialized',
                message: 'Database connection failed'
            });
        }

        const status = {
            connected: true,
            path: dbPath,
            tables: {}
        };

        // Check each table
        const tables = ['stok', 'satisGecmisi', 'musteriler', 'borclarim'];
        tables.forEach(table => {
            try {
                const count = db.prepare(`SELECT COUNT(*) as count FROM ${table}`).get();
                status.tables[table] = {
                    exists: true,
                    count: count.count
                };
            } catch (error) {
                status.tables[table] = {
                    exists: false,
                    error: error.message
                };
            }
        });

        res.json({
            success: true,
            status: status
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// Basit HTML test sayfasÄ±
app.get('/test', (req, res) => {
    res.send(`
        <!DOCTYPE html>
        <html>
        <head>
            <title>Server Test</title>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
        </head>
        <body style="font-family: Arial; padding: 20px; background: #f0f0f0;">
            <h1>ğŸš€ Server Test SayfasÄ±</h1>
            <p><strong>Status:</strong> âœ… Server Ã‡alÄ±ÅŸÄ±yor!</p>
            <p><strong>Time:</strong> ${new Date().toLocaleString('tr-TR')}</p>
            <p><strong>IP:</strong> ${req.ip || req.connection.remoteAddress}</p>
            <hr>
            <h3>ğŸ”— Linkler:</h3>
            <ul>
                <li><a href="/">Ana Sayfa</a></li>
                <li><a href="/api/tum-veriler">API Test</a></li>
                <li><a href="/qr">QR BaÄŸlantÄ±</a></li>
                <li><a href="/api/database-status">Database Status</a></li>
            </ul>
            <hr>
            <button onclick="testAPI()" style="padding: 10px 20px; font-size: 16px;">API Test Et</button>
            <div id="result" style="margin-top: 20px; padding: 10px; background: white; border-radius: 5px;"></div>
            
            <script>
                async function testAPI() {
                    const resultDiv = document.getElementById('result');
                    try {
                        const response = await fetch('/api/tum-veriler');
                        const data = await response.json();
                        resultDiv.innerHTML = '<h4>âœ… API Test BaÅŸarÄ±lÄ±:</h4><pre>' + JSON.stringify(data, null, 2) + '</pre>';
                        resultDiv.style.borderLeft = '4px solid #27ae60';
                    } catch (error) {
                        resultDiv.innerHTML = '<h4>âŒ API Test BaÅŸarÄ±sÄ±z:</h4><p>' + error.message + '</p>';
                        resultDiv.style.borderLeft = '4px solid #e74c3c';
                    }
                }
            </script>
        </body>
        </html>
    `);
});

// Sunucuyu baÅŸlat
async function startServer() {
    const os = require('os');
    
    // TÃ¼m network interface'lerinde dinle (0.0.0.0) - WebSocket server kullan
    server.listen(PORT, '0.0.0.0', () => {
        console.log(`ğŸš€ Server Ã§alÄ±ÅŸÄ±yor!`);
        console.log(`ğŸ“ Local: http://localhost:${PORT}`);
        
        // TÃ¼m IP adreslerini gÃ¶ster
        const networkInterfaces = os.networkInterfaces();
        console.log(`ğŸŒ Network adresleri:`);
        
        Object.keys(networkInterfaces).forEach(interfaceName => {
            const interfaces = networkInterfaces[interfaceName];
            interfaces.forEach(iface => {
                if (iface.family === 'IPv4' && !iface.internal) {
                    console.log(`   - http://${iface.address}:${PORT}`);
                }
            });
        });
        
        console.log(`ğŸ“ Veriler klasÃ¶rÃ¼: ${dataDir}`);
        console.log(`ğŸ“„ Veri dosyalarÄ±:`);
        console.log(`   - Stok: ${stockFile}`);
        console.log(`   - SatÄ±ÅŸlar: ${salesFile}`);
        console.log(`   - MÃ¼ÅŸteriler: ${customersFile}`);
        console.log(`   - TÃ¼m Veriler: ${allDataFile}`);
        console.log('');
        console.log('API Endpoints:');
        console.log(`  GET  /api/tum-veriler - TÃ¼m verileri getir`);
        console.log(`  POST /api/tum-veriler - TÃ¼m verileri kaydet`);
        console.log(`  GET  /qr - QR baÄŸlantÄ± sayfasÄ±`);
        console.log(`  GET  /api/network-info - Network bilgileri`);
        console.log(`  POST /api/reset-database - VeritabanÄ±nÄ± sÄ±fÄ±rla`);
        console.log(`  GET  /api/database-status - VeritabanÄ± durumu`);
        console.log('');
        console.log('ğŸ’¡ Hibrit kullanÄ±m iÃ§in optimize edildi');
        console.log('ğŸ’¾ Otomatik veri kaydetme aktif');
        console.log('ğŸ”— ArtÄ±k network eriÅŸimi mevcut!');
    });
}

startServer().catch(console.error);