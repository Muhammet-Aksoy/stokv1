const express = require('express');
const http = require('http');
const socketIo = require('socket.io');
const cors = require('cors');
const Database = require('better-sqlite3');
const path = require('path');
const fs = require('fs-extra');
const nodemailer = require('nodemailer');

// Server configuration
const PORT = process.env.PORT || 3000;
const app = express();
const server = http.createServer(app);
const io = socketIo(server, {
    cors: {
        origin: "*",
        methods: ["GET", "POST"]
    }
});

// Database configuration
const dbPath = path.join(__dirname, 'veriler', 'veritabani.db');
let db = null;

// Email configuration for daily backups
const emailConfig = require('./email-config');

// Email transporter
let transporter = null;
try {
    transporter = nodemailer.createTransporter(emailConfig);
} catch (error) {
    console.warn('‚ö†Ô∏è Email configuration not set up:', error.message);
}

// Middleware
app.use(cors());
app.use(express.json({ limit: '50mb' }));
app.use(express.urlencoded({ limit: '50mb', extended: true }));
app.use(express.static('.'));

// Database initialization with proper error handling
function initializeDatabase() {
    try {
        // Ensure data directory exists
        fs.ensureDirSync(path.dirname(dbPath));
        
        // Initialize database
        db = new Database(dbPath);
        console.log('‚úÖ Database connected:', dbPath);
        
        // Enable foreign keys and optimize performance
        db.exec('PRAGMA foreign_keys = ON');
        db.exec('PRAGMA journal_mode = WAL');
        db.exec('PRAGMA synchronous = NORMAL');
        
        // Create tables with proper schema
        db.exec(`
            CREATE TABLE IF NOT EXISTS stok (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                barkod TEXT NOT NULL,
                ad TEXT NOT NULL,
                marka TEXT,
                miktar INTEGER DEFAULT 0,
                alisFiyati REAL DEFAULT 0,
                satisFiyati REAL DEFAULT 0,
                kategori TEXT,
                aciklama TEXT,
                varyant_id TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(barkod, marka, varyant_id)
            )
        `);
        
        db.exec(`
            CREATE TABLE IF NOT EXISTS musteriler (
                id TEXT PRIMARY KEY,
                ad TEXT NOT NULL,
                telefon TEXT,
                adres TEXT,
                bakiye REAL DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);
        
        db.exec(`
            CREATE TABLE IF NOT EXISTS satisGecmisi (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                barkod TEXT NOT NULL,
                miktar INTEGER DEFAULT 0,
                fiyat REAL DEFAULT 0,
                alisFiyati REAL DEFAULT 0,
                musteriId TEXT,
                tarih DATETIME DEFAULT CURRENT_TIMESTAMP,
                borc INTEGER DEFAULT 0,
                toplam REAL DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);
        
        db.exec(`
            CREATE TABLE IF NOT EXISTS borclarim (
                id TEXT PRIMARY KEY,
                musteriId TEXT NOT NULL,
                tutar REAL DEFAULT 0,
                aciklama TEXT,
                tarih DATETIME DEFAULT CURRENT_TIMESTAMP,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);
        
        // Add missing columns safely
        const addColumnSafely = (table, column, definition) => {
            try {
                db.exec(`ALTER TABLE ${table} ADD COLUMN ${column} ${definition}`);
                console.log(`‚úÖ Added ${column} to ${table}`);
            } catch (e) {
                console.log(`‚ÑπÔ∏è ${column} already exists in ${table}`);
            }
        };
        
        addColumnSafely('stok', 'updated_at', 'DATETIME DEFAULT CURRENT_TIMESTAMP');
        addColumnSafely('musteriler', 'updated_at', 'DATETIME DEFAULT CURRENT_TIMESTAMP');
        addColumnSafely('musteriler', 'created_at', 'DATETIME DEFAULT CURRENT_TIMESTAMP');
        addColumnSafely('satisGecmisi', 'created_at', 'DATETIME DEFAULT CURRENT_TIMESTAMP');
        addColumnSafely('borclarim', 'created_at', 'DATETIME DEFAULT CURRENT_TIMESTAMP');
        
        // Create indices for better performance
        db.exec(`
            CREATE INDEX IF NOT EXISTS idx_stok_barkod ON stok(barkod);
            CREATE INDEX IF NOT EXISTS idx_satis_tarih ON satisGecmisi(tarih);
            CREATE INDEX IF NOT EXISTS idx_musteri_updated ON musteriler(updated_at);
        `);
        
        // Add marka column if it doesn't exist (migration for existing databases)
        try {
            db.prepare('SELECT marka FROM stok LIMIT 1').get();
        } catch (e) {
            console.log('üì¶ Adding marka column to stok table...');
            db.exec('ALTER TABLE stok ADD COLUMN marka TEXT');
        }
        
        // Add varyant_id column if it doesn't exist (migration for existing databases)
        try {
            db.prepare('SELECT varyant_id FROM stok LIMIT 1').get();
        } catch (e) {
            console.log('üì¶ Adding varyant_id column to stok table...');
            db.exec('ALTER TABLE stok ADD COLUMN varyant_id TEXT');
        }
        
        // Initialize database with sample data if empty
        const stokCount = db.prepare('SELECT COUNT(*) as count FROM stok').get().count;
        const musteriCount = db.prepare('SELECT COUNT(*) as count FROM musteriler').get().count;
        
        console.log('‚úÖ Database initialized successfully');
        
        // Verify tables
        const tables = db.prepare("SELECT name FROM sqlite_master WHERE type='table'").all();
        console.log('üìä Available tables:', tables.map(t => t.name));
        
    } catch (error) {
        console.error('‚ùå Database initialization failed:', error.message);
        process.exit(1);
    }
}

// Initialize database
initializeDatabase();

// Socket.IO connection handling
io.on('connection', (socket) => {
    console.log('üîó Client connected:', socket.id);
    
    socket.on('disconnect', () => {
        console.log('‚ùå Client disconnected:', socket.id);
    });
    
    // Send initial connection confirmation
    socket.emit('connected', {
        message: 'Ba≈üarƒ±yla baƒülandƒ±',
        timestamp: new Date().toISOString(),
        socketId: socket.id
    });
    
    // Handle data requests with robust error handling
    socket.on('requestData', async () => {
        try {
            console.log('üì° Data request from client:', socket.id);
            
            const data = db.transaction(() => {
                let stokListesi = {};
                let satisGecmisi = [];
                let musteriler = {};
                let borclarim = {};
                
                // Get stok data
                try {
                    const stokRows = db.prepare('SELECT * FROM stok ORDER BY updated_at DESC').all();
                    stokRows.forEach(row => { 
                        // Use barkod as the key for simpler access
                        const key = row.barkod;
                        stokListesi[key] = row;
                    });
                } catch (e) {
                    console.warn('‚ö†Ô∏è Stok query error:', e.message);
                    // Fallback
                    const stokRows = db.prepare('SELECT * FROM stok ORDER BY id DESC').all();
                    stokRows.forEach(row => { 
                        const key = row.barkod;
                        stokListesi[key] = row;
                    });
                }
                
                // Get satis data
                try {
                    satisGecmisi = db.prepare('SELECT * FROM satisGecmisi ORDER BY tarih DESC').all();
                } catch (e) {
                    console.warn('‚ö†Ô∏è Satis query error:', e.message);
                }
                
                // Get musteriler data
                try {
                    const musteriRows = db.prepare('SELECT * FROM musteriler ORDER BY updated_at DESC').all();
                    musteriRows.forEach(row => { musteriler[row.id] = row; });
                } catch (e) {
                    console.warn('‚ö†Ô∏è Musteri query error:', e.message);
                    // Fallback
                    const musteriRows = db.prepare('SELECT * FROM musteriler ORDER BY id DESC').all();
                    musteriRows.forEach(row => { musteriler[row.id] = row; });
                }
                
                // Get borclarim data
                try {
                    const borcRows = db.prepare('SELECT * FROM borclarim ORDER BY tarih DESC').all();
                    borcRows.forEach(row => { borclarim[row.id] = row; });
                } catch (e) {
                    console.warn('‚ö†Ô∏è Borc query error:', e.message);
                }
                
                return { stokListesi, satisGecmisi, musteriler, borclarim };
            })();
            
            socket.emit('dataResponse', {
                success: true,
                data: data,
                timestamp: new Date().toISOString(),
                count: {
                    stok: Object.keys(data.stokListesi).length,
                    satis: data.satisGecmisi.length,
                    musteri: Object.keys(data.musteriler).length,
                    borc: Object.keys(data.borclarim).length
                }
            });
            
            console.log('‚úÖ Data sent to client:', socket.id);
            
        } catch (error) {
            console.error('‚ùå Data request error:', error);
            socket.emit('dataResponse', {
                success: false,
                error: error.message,
                timestamp: new Date().toISOString()
            });
        }
    });
    
    // Handle real-time data updates
    socket.on('dataUpdate', (data) => {
        try {
            console.log('üì° Data update received:', data.type);
            
            if (!data.type || !data.data) {
                throw new Error('Invalid data update format');
            }
            
            // Broadcast to all clients
            socket.broadcast.emit('dataUpdate', data);
            
            socket.emit('updateResponse', {
                success: true,
                message: 'Data updated successfully',
                timestamp: new Date().toISOString()
            });
            
        } catch (error) {
            console.error('‚ùå Data update error:', error);
            socket.emit('updateResponse', {
                success: false,
                error: error.message,
                timestamp: new Date().toISOString()
            });
        }
    });
});

// API Routes
app.get('/api/test', (req, res) => {
    try {
        // Database connection test
        const dbTest = db.prepare('SELECT 1 as test').get();
        
        // Table structure test
        const stokColumns = db.prepare("PRAGMA table_info(stok)").all();
        const musteriColumns = db.prepare("PRAGMA table_info(musteriler)").all();
        
        // Data count test
        const stokCount = db.prepare('SELECT COUNT(*) as count FROM stok').get();
        const musteriCount = db.prepare('SELECT COUNT(*) as count FROM musteriler').get();
        const satisCount = db.prepare('SELECT COUNT(*) as count FROM satisGecmisi').get();
        const borcCount = db.prepare('SELECT COUNT(*) as count FROM borclarim').get();
        
        res.json({
            success: true,
            message: 'API √ßalƒ±≈üƒ±yor',
            timestamp: new Date().toISOString(),
            database: {
                connected: true,
                test: dbTest.test
            },
            tables: {
                stok: {
                    exists: stokColumns.length > 0,
                    columns: stokColumns.map(col => col.name),
                    count: stokCount.count,
                    hasUpdatedAt: stokColumns.some(col => col.name === 'updated_at')
                },
                musteriler: {
                    exists: musteriColumns.length > 0,
                    columns: musteriColumns.map(col => col.name),
                    count: musteriCount.count,
                    hasUpdatedAt: musteriColumns.some(col => col.name === 'updated_at')
                },
                satisGecmisi: {
                    count: satisCount.count
                },
                borclarim: {
                    count: borcCount.count
                }
            },
            socket: {
                connected: io.engine.clientsCount,
                rooms: Object.keys(io.sockets.adapter.rooms)
            }
        });
        
    } catch (error) {
        console.error('‚ùå Test endpoint error:', error);
        res.status(500).json({
            success: false,
            message: 'Test ba≈üarƒ±sƒ±z',
            error: error.message,
            timestamp: new Date().toISOString()
        });
    }
});

// GET endpoint for all data
app.get('/api/tum-veriler', async (req, res) => {
    try {
        const data = db.transaction(() => {
            let stokListesi = {};
            let satisGecmisi = [];
            let musteriler = {};
            let borclarim = {};
            
            // Get all data - Index by barkod for simpler identification
            const stokRows = db.prepare('SELECT * FROM stok ORDER BY updated_at DESC').all();
            stokRows.forEach(row => { 
                // Use barkod as the key for simpler access
                const key = row.barkod;
                stokListesi[key] = row; 
            });
            
            satisGecmisi = db.prepare('SELECT * FROM satisGecmisi ORDER BY tarih DESC').all();
            
            const musteriRows = db.prepare('SELECT * FROM musteriler ORDER BY updated_at DESC').all();
            musteriRows.forEach(row => { musteriler[row.id] = row; });
            
            const borcRows = db.prepare('SELECT * FROM borclarim ORDER BY tarih DESC').all();
            borcRows.forEach(row => { borclarim[row.id] = row; });
            
            return { stokListesi, satisGecmisi, musteriler, borclarim };
        })();
        
        res.json({
            success: true,
            data: data,
            timestamp: new Date().toISOString(),
            count: {
                stok: Object.keys(data.stokListesi).length,
                satis: data.satisGecmisi.length,
                musteri: Object.keys(data.musteriler).length,
                borc: Object.keys(data.borclarim).length
            }
        });
        
    } catch (error) {
        console.error('‚ùå Tum veriler error:', error);
        res.status(500).json({
            success: false,
            error: error.message,
            timestamp: new Date().toISOString()
        });
    }
});

// POST endpoint for bulk data synchronization
app.post('/api/tum-veriler', async (req, res) => {
    try {
        const { stokListesi, satisGecmisi, musteriler, borclarim } = req.body;
        
        if (!stokListesi || !satisGecmisi || !musteriler || !borclarim) {
            return res.status(400).json({
                success: false,
                error: 'Eksik veri parametreleri',
                timestamp: new Date().toISOString()
            });
        }
        
        const result = db.transaction(() => {
            let updatedCount = 0;
            let insertedCount = 0;
            
            // Sync stok data
            for (const [key, urun] of Object.entries(stokListesi)) {
                try {
                    // Handle both old structure (product ID as key) and new structure (barcode as key)
                    const barkod = urun.barkod || key;
                    const marka = urun.marka || '';
                    const varyant_id = urun.varyant_id || '';
                    
                    // Check for existing record using the composite unique constraint
                    const existing = db.prepare('SELECT id FROM stok WHERE barkod = ? AND marka = ? AND varyant_id = ?').get(barkod, marka, varyant_id);
                    
                    if (existing) {
                        // Ensure proper data types and handle null/undefined values
                        const ad = urun.ad || '';
                        const miktar = parseInt(urun.miktar) || 0;
                        const alisFiyati = parseFloat(urun.alisFiyati) || 0;
                        const satisFiyati = parseFloat(urun.satisFiyati) || 0;
                        const kategori = urun.kategori || '';
                        const aciklama = urun.aciklama || '';
                        
                        db.prepare(`
                            UPDATE stok SET 
                                ad = ?, miktar = ?, alisFiyati = ?, satisFiyati = ?, 
                                kategori = ?, aciklama = ?, updated_at = CURRENT_TIMESTAMP
                            WHERE barkod = ? AND marka = ? AND varyant_id = ?
                        `).run(ad, miktar, alisFiyati, satisFiyati, kategori, aciklama, barkod, marka, varyant_id);
                        updatedCount++;
                    } else {
                        // Ensure proper data types and handle null/undefined values
                        const ad = urun.ad || '';
                        const miktar = parseInt(urun.miktar) || 0;
                        const alisFiyati = parseFloat(urun.alisFiyati) || 0;
                        const satisFiyati = parseFloat(urun.satisFiyati) || 0;
                        const kategori = urun.kategori || '';
                        const aciklama = urun.aciklama || '';
                        
                        db.prepare(`
                            INSERT INTO stok (barkod, ad, marka, miktar, alisFiyati, satisFiyati, kategori, aciklama, varyant_id)
                            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                        `).run(barkod, ad, marka, miktar, alisFiyati, satisFiyati, kategori, aciklama, varyant_id);
                        insertedCount++;
                    }
                } catch (e) {
                    console.warn(`‚ö†Ô∏è Stok sync error for ${key}:`, e.message);
                }
            }
            
            // Sync satis data
            for (const satis of satisGecmisi) {
                try {
                    const existing = db.prepare('SELECT id FROM satisGecmisi WHERE id = ?').get(satis.id);
                    
                    if (!existing) {
                        // Ensure proper data types and handle null/undefined values
                        const barkod = satis.barkod || '';
                        const miktar = parseInt(satis.miktar) || 0;
                        const fiyat = parseFloat(satis.fiyat) || 0;
                        const alisFiyati = parseFloat(satis.alisFiyati) || 0;
                        const musteriId = satis.musteriId || null;
                        const tarih = satis.tarih || new Date().toISOString();
                        const borc = satis.borc ? 1 : 0;
                        const toplam = parseFloat(satis.toplam) || 0;
                        
                        db.prepare(`
                            INSERT INTO satisGecmisi (barkod, miktar, fiyat, alisFiyati, musteriId, tarih, borc, toplam)
                            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                        `).run(barkod, miktar, fiyat, alisFiyati, musteriId, tarih, borc, toplam);
                        insertedCount++;
                    }
                } catch (e) {
                    console.warn(`‚ö†Ô∏è Satis sync error for ${satis.id}:`, e.message);
                }
            }
            
            // Sync musteriler data
            for (const [id, musteri] of Object.entries(musteriler)) {
                try {
                    const existing = db.prepare('SELECT id FROM musteriler WHERE id = ?').get(id);
                    
                    if (existing) {
                        // Ensure proper data types and handle null/undefined values
                        const ad = musteri.ad || '';
                        const telefon = musteri.telefon || '';
                        const adres = musteri.adres || '';
                        const bakiye = parseFloat(musteri.bakiye) || 0;
                        
                        db.prepare(`
                            UPDATE musteriler SET 
                                ad = ?, telefon = ?, adres = ?, bakiye = ?, updated_at = CURRENT_TIMESTAMP
                            WHERE id = ?
                        `).run(ad, telefon, adres, bakiye, id);
                        updatedCount++;
                    } else {
                        // Ensure proper data types and handle null/undefined values
                        const ad = musteri.ad || '';
                        const telefon = musteri.telefon || '';
                        const adres = musteri.adres || '';
                        const bakiye = parseFloat(musteri.bakiye) || 0;
                        
                        db.prepare(`
                            INSERT INTO musteriler (id, ad, telefon, adres, bakiye)
                            VALUES (?, ?, ?, ?, ?)
                        `).run(id, ad, telefon, adres, bakiye);
                        insertedCount++;
                    }
                } catch (e) {
                    console.warn(`‚ö†Ô∏è Musteri sync error for ${id}:`, e.message);
                }
            }
            
            // Sync borclarim data
            for (const [id, borc] of Object.entries(borclarim)) {
                try {
                    const existing = db.prepare('SELECT id FROM borclarim WHERE id = ?').get(id);
                    
                    if (existing) {
                        // Ensure proper data types and handle null/undefined values
                        const musteriId = borc.musteriId || '';
                        const tutar = parseFloat(borc.tutar) || 0;
                        const aciklama = borc.aciklama || '';
                        const tarih = borc.tarih || new Date().toISOString();
                        
                        db.prepare(`
                            UPDATE borclarim SET 
                                musteriId = ?, tutar = ?, aciklama = ?, tarih = ?
                            WHERE id = ?
                        `).run(musteriId, tutar, aciklama, tarih, id);
                        updatedCount++;
                    } else {
                        // Ensure proper data types and handle null/undefined values
                        const musteriId = borc.musteriId || '';
                        const tutar = parseFloat(borc.tutar) || 0;
                        const aciklama = borc.aciklama || '';
                        const tarih = borc.tarih || new Date().toISOString();
                        
                        db.prepare(`
                            INSERT INTO borclarim (id, musteriId, tutar, aciklama, tarih)
                            VALUES (?, ?, ?, ?, ?)
                        `).run(id, musteriId, tutar, aciklama, tarih);
                        insertedCount++;
                    }
                } catch (e) {
                    console.warn(`‚ö†Ô∏è Borc sync error for ${id}:`, e.message);
                }
            }
            
            return { updatedCount, insertedCount };
        })();
        
        res.json({
            success: true,
            message: 'Veriler ba≈üarƒ±yla senkronize edildi',
            result: result,
            timestamp: new Date().toISOString()
        });
        
    } catch (error) {
        console.error('‚ùå Tum veriler POST error:', error);
        res.status(500).json({
            success: false,
            error: error.message,
            timestamp: new Date().toISOString()
        });
    }
});

app.get('/api/database-status', (req, res) => {
    try {
        const status = {
            connected: db !== null,
            path: dbPath,
            tables: [],
            indexes: []
        };
        
        if (db) {
            // Get table info
            const tables = db.prepare("SELECT name FROM sqlite_master WHERE type='table'").all();
            status.tables = tables.map(t => t.name);
            
            // Get index info
            const indexes = db.prepare("SELECT name FROM sqlite_master WHERE type='index'").all();
            status.indexes = indexes.map(i => i.name);
            
            // Test connection
            const test = db.prepare('SELECT 1 as test').get();
            status.test = test.test;
        }
        
        res.json({
            success: true,
            status: status,
            timestamp: new Date().toISOString()
        });
        
    } catch (error) {
        console.error('‚ùå Database status error:', error);
        res.status(500).json({
            success: false,
            error: error.message,
            timestamp: new Date().toISOString()
        });
    }
});

// Debug endpoint
app.get('/api/debug', (req, res) => {
    try {
        const debug = {
            server: {
                status: 'running',
                uptime: process.uptime(),
                memory: process.memoryUsage(),
                version: process.version,
                platform: process.platform
            },
            database: {
                status: db !== null ? 'connected' : 'disconnected',
                path: dbPath,
                tables: []
            }
        };

        if (db) {
            // Get table information
            const tables = db.prepare("SELECT name FROM sqlite_master WHERE type='table'").all();
            debug.database.tables = tables.map(table => {
                try {
                    const count = db.prepare(`SELECT COUNT(*) as count FROM ${table.name}`).get().count;
                    return {
                        name: table.name,
                        count: count,
                        status: 'ok'
                    };
                } catch (e) {
                    return {
                        name: table.name,
                        count: 0,
                        status: 'error'
                    };
                }
            });
        }

        res.json({
            success: true,
            debug: debug,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('‚ùå Debug endpoint error:', error);
        res.status(500).json({
            success: false,
            error: error.message,
            timestamp: new Date().toISOString()
        });
    }
});

// Email backup function
async function sendDailyBackup() {
    if (!transporter) {
        console.warn('‚ö†Ô∏è Email transporter not configured');
        return;
    }

    try {
        // Create backup
        const backupDir = path.join(__dirname, 'veriler', 'backups');
        fs.ensureDirSync(backupDir);
        
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const backupPath = path.join(backupDir, `daily_backup_${timestamp}.db`);
        
        // Copy database
        fs.copyFileSync(dbPath, backupPath);
        
        // Get database stats
        const stats = db.transaction(() => {
            const stokCount = db.prepare('SELECT COUNT(*) as count FROM stok').get().count;
            const satisCount = db.prepare('SELECT COUNT(*) as count FROM satisGecmisi').get().count;
            const musteriCount = db.prepare('SELECT COUNT(*) as count FROM musteriler').get().count;
            const borcCount = db.prepare('SELECT COUNT(*) as count FROM borclarim').get().count;
            
            return { stokCount, satisCount, musteriCount, borcCount };
        })();
        
        // Send email
        const mailOptions = {
            from: emailConfig.auth.user,
            to: emailConfig.auth.user, // Send to self as backup
            subject: `G√ºnl√ºk Veri Yedeƒüi - ${new Date().toLocaleDateString('tr-TR')}`,
            html: `
                <h2>üìä G√ºnl√ºk Veri Yedeƒüi</h2>
                <p><strong>Tarih:</strong> ${new Date().toLocaleString('tr-TR')}</p>
                <p><strong>Veritabanƒ± ƒ∞statistikleri:</strong></p>
                <ul>
                    <li>üì¶ √úr√ºn Sayƒ±sƒ±: ${stats.stokCount}</li>
                    <li>üí∞ Satƒ±≈ü Sayƒ±sƒ±: ${stats.satisCount}</li>
                    <li>üë• M√º≈üteri Sayƒ±sƒ±: ${stats.musteriCount}</li>
                    <li>üí≥ Bor√ß Sayƒ±sƒ±: ${stats.borcCount}</li>
                </ul>
                <p><strong>Yedek Dosya:</strong> ${path.basename(backupPath)}</p>
                <p><em>Bu yedek dosyasƒ± bilgisayarƒ±nƒ±zda saklanmaktadƒ±r.</em></p>
            `,
            attachments: [{
                filename: `backup_${timestamp}.db`,
                path: backupPath
            }]
        };
        
        await transporter.sendMail(mailOptions);
        console.log('‚úÖ Daily backup email sent successfully');
        
        // Clean up old backups (keep last 7 days)
        const files = fs.readdirSync(backupDir);
        const oldFiles = files
            .filter(f => f.startsWith('daily_backup_'))
            .sort()
            .slice(0, -7); // Keep only last 7 files
            
        oldFiles.forEach(file => {
            fs.removeSync(path.join(backupDir, file));
        });
        
    } catch (error) {
        console.error('‚ùå Daily backup email failed:', error);
    }
}

// Schedule daily backup at 23:00
setInterval(() => {
    const now = new Date();
    if (now.getHours() === 23 && now.getMinutes() === 0) {
        sendDailyBackup();
    }
}, 60000); // Check every minute

// POST /api/stok-ekle - Tek √ºr√ºn ekle
app.post('/api/stok-ekle', async (req, res) => {
    try {
        const urun = req.body;
        console.log('üì¶ Yeni √ºr√ºn ekleniyor:', urun.barkod, urun.ad);
        
        // Validate required fields
        if (!urun.barkod || !urun.ad) {
            return res.status(400).json({
                success: false,
                message: 'Barkod ve √ºr√ºn adƒ± zorunludur',
                timestamp: new Date().toISOString()
            });
        }
        
        // Ensure proper data types and handle null/undefined values
        const barkod = urun.barkod || '';
        const ad = urun.ad || '';
        const marka = urun.marka || '';
        const miktar = parseInt(urun.miktar) || 0;
        const alisFiyati = parseFloat(urun.alisFiyati) || 0;
        const satisFiyati = parseFloat(urun.satisFiyati) || 0;
        const kategori = urun.kategori || '';
        const aciklama = urun.aciklama || '';
        const varyant_id = urun.varyant_id || '';
        
        // Check if same barkod and marka combination exists
        const existingProduct = db.prepare('SELECT * FROM stok WHERE barkod = ? AND marka = ? AND varyant_id = ?').get(barkod, marka, varyant_id);
        
        if (existingProduct) {
            // Update existing product
            const result = db.prepare(`
                UPDATE stok SET 
                    ad = ?, miktar = ?, alisFiyati = ?, satisFiyati = ?, 
                    kategori = ?, aciklama = ?, updated_at = CURRENT_TIMESTAMP 
                WHERE barkod = ? AND marka = ? AND varyant_id = ?
            `).run(ad, miktar, alisFiyati, satisFiyati, kategori, aciklama, barkod, marka, varyant_id);
            
            const updatedProduct = db.prepare('SELECT * FROM stok WHERE barkod = ? AND marka = ? AND varyant_id = ?').get(barkod, marka, varyant_id);
            
            // Real-time sync to all clients
            io.to('dataSync').emit('dataUpdated', {
                type: 'stok-update',
                data: updatedProduct,
                timestamp: new Date().toISOString()
            });
            
            res.json({ 
                success: true, 
                message: 'Mevcut √ºr√ºn g√ºncellendi', 
                data: updatedProduct,
                isUpdate: true,
                timestamp: new Date().toISOString()
            });
        } else {
            // Insert new product
            const result = db.prepare(`
                INSERT INTO stok (barkod, ad, marka, miktar, alisFiyati, satisFiyati, kategori, aciklama, varyant_id, updated_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
            `).run(barkod, ad, marka, miktar, alisFiyati, satisFiyati, kategori, aciklama, varyant_id);
            
            // Get the inserted product with its ID
            const insertedProduct = db.prepare('SELECT * FROM stok WHERE barkod = ? AND marka = ? AND varyant_id = ?').get(barkod, marka, varyant_id);
            
            // Real-time sync to all clients
            io.to('dataSync').emit('dataUpdated', {
                type: 'stok-add',
                data: insertedProduct,
                timestamp: new Date().toISOString()
            });
            
            res.status(201).json({ 
                success: true, 
                message: 'Yeni √ºr√ºn ba≈üarƒ±yla eklendi', 
                data: insertedProduct,
                isUpdate: false,
                timestamp: new Date().toISOString()
            });
        }
        
    } catch (error) {
        console.error('‚ùå √úr√ºn eklenirken hata:', error);
        res.status(500).json({ 
            success: false, 
            message: '√úr√ºn eklenirken hata', 
            error: error.message,
            timestamp: new Date().toISOString()
        });
    }
});

// PUT /api/stok-guncelle - √úr√ºn g√ºncelle
app.put('/api/stok-guncelle', async (req, res) => {
    try {
        const urun = req.body;
        console.log('üîÑ √úr√ºn g√ºncelleniyor:', urun.barkod);
        
        // Ensure proper data types and handle null/undefined values
        const barkod = urun.barkod || '';
        const ad = urun.ad || '';
        const marka = urun.marka || '';
        const miktar = parseInt(urun.miktar) || 0;
        const alisFiyati = parseFloat(urun.alisFiyati) || 0;
        const satisFiyati = parseFloat(urun.satisFiyati) || 0;
        const kategori = urun.kategori || '';
        const aciklama = urun.aciklama || '';
        const varyant_id = urun.varyant_id || '';
        const id = urun.id; // Use ID for precise update
        
        if (!id) {
            return res.status(400).json({
                success: false,
                message: '√úr√ºn ID gerekli',
                timestamp: new Date().toISOString()
            });
        }
        
        const result = db.prepare(`
            UPDATE stok SET 
                ad = ?, marka = ?, miktar = ?, alisFiyati = ?, satisFiyati = ?, 
                kategori = ?, aciklama = ?, varyant_id = ?, updated_at = CURRENT_TIMESTAMP 
            WHERE id = ?
        `).run(ad, marka, miktar, alisFiyati, satisFiyati, kategori, aciklama, varyant_id, id);
        
        if (result.changes > 0) {
            // Get the updated product with its ID
            const updatedProduct = db.prepare('SELECT * FROM stok WHERE id = ?').get(id);
            
            // Real-time sync to all clients
            io.to('dataSync').emit('dataUpdated', {
                type: 'stok-update',
                data: updatedProduct,
                timestamp: new Date().toISOString()
            });
            
            res.json({ 
                success: true, 
                message: '√úr√ºn ba≈üarƒ±yla g√ºncellendi', 
                data: updatedProduct,
                timestamp: new Date().toISOString()
            });
        } else {
            res.status(404).json({ 
                success: false, 
                message: '√úr√ºn bulunamadƒ±', 
                timestamp: new Date().toISOString()
            });
        }
        
    } catch (error) {
        console.error('‚ùå √úr√ºn g√ºncellenirken hata:', error);
        res.status(500).json({ 
            success: false, 
            message: '√úr√ºn g√ºncellenirken hata', 
            error: error.message,
            timestamp: new Date().toISOString()
        });
    }
});

// GET /api/stok-varyantlar/:barkod - Aynƒ± barkodlu √ºr√ºn varyantlarƒ±nƒ± getir
app.get('/api/stok-varyantlar/:barkod', async (req, res) => {
    try {
        const { barkod } = req.params;
        console.log('üîç Barkod varyantlarƒ± aranƒ±yor:', barkod);
        
        const variants = db.prepare('SELECT * FROM stok WHERE barkod = ? ORDER BY marka, varyant_id').all(barkod);
        
        res.json({
            success: true,
            data: variants,
            count: variants.length,
            barkod: barkod,
            timestamp: new Date().toISOString()
        });
        
    } catch (error) {
        console.error('‚ùå Varyant arama hatasƒ±:', error);
        res.status(500).json({
            success: false,
            message: 'Varyant arama hatasƒ±',
            error: error.message,
            timestamp: new Date().toISOString()
        });
    }
});

// DELETE /api/stok-sil/:barkod - √úr√ºn sil
app.delete('/api/stok-sil/:barkod', async (req, res) => {
    try {
        const { barkod } = req.params;
        console.log('üóëÔ∏è √úr√ºn siliniyor:', barkod);
        
        const result = db.prepare('DELETE FROM stok WHERE barkod = ?').run(barkod);
        
        if (result.changes > 0) {
            // Real-time sync to all clients
            io.to('dataSync').emit('dataUpdated', {
                type: 'stok-delete',
                data: { barkod },
                timestamp: new Date().toISOString()
            });
            
            res.json({ 
                success: true, 
                message: '√úr√ºn ba≈üarƒ±yla silindi',
                timestamp: new Date().toISOString()
            });
        } else {
            res.status(404).json({ 
                success: false, 
                message: '√úr√ºn bulunamadƒ±',
                timestamp: new Date().toISOString()
            });
        }
        
    } catch (error) {
        console.error('‚ùå √úr√ºn silinirken hata:', error);
        res.status(500).json({ 
            success: false, 
            message: '√úr√ºn silinirken hata', 
            error: error.message,
            timestamp: new Date().toISOString()
        });
    }
});

// POST /api/satis-ekle - Satƒ±≈ü ekle
app.post('/api/satis-ekle', async (req, res) => {
    try {
        const satis = req.body;
        console.log('üí∞ Yeni satƒ±≈ü ekleniyor:', satis.barkod, satis.miktar);
        
        // Validate required fields
        if (!satis.barkod || !satis.miktar || satis.miktar <= 0) {
            return res.status(400).json({
                success: false,
                message: 'Barkod ve miktar zorunludur ve miktar 0\'dan b√ºy√ºk olmalƒ±dƒ±r',
                timestamp: new Date().toISOString()
            });
        }
        
        // Ensure proper data types and handle null/undefined values
        const barkod = satis.barkod || '';
        const miktar = parseInt(satis.miktar) || 0;
        const fiyat = parseFloat(satis.fiyat) || 0;
        const alisFiyati = parseFloat(satis.alisFiyati) || 0;
        const musteriId = satis.musteriId || null;
        const tarih = satis.tarih || new Date().toISOString();
        const borc = satis.borc ? 1 : 0;
        const toplam = parseFloat(satis.toplam) || (fiyat * miktar);
        
        const result = db.prepare(`
            INSERT INTO satisGecmisi (barkod, miktar, fiyat, alisFiyati, musteriId, tarih, borc, toplam)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `).run(barkod, miktar, fiyat, alisFiyati, musteriId, tarih, borc, toplam);
        
        // Real-time sync to all clients
        io.to('dataSync').emit('dataUpdated', {
            type: 'satis-add',
            data: satis,
            timestamp: new Date().toISOString()
        });
        
        res.status(201).json({ 
            success: true, 
            message: 'Satƒ±≈ü ba≈üarƒ±yla kaydedildi', 
            data: satis,
            timestamp: new Date().toISOString()
        });
        
    } catch (error) {
        console.error('‚ùå Satƒ±≈ü eklenirken hata:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Satƒ±≈ü eklenirken hata', 
            error: error.message,
            timestamp: new Date().toISOString()
        });
    }
});

// POST /api/musteri-ekle - M√º≈üteri ekle
app.post('/api/musteri-ekle', async (req, res) => {
    try {
        const musteri = req.body;
        console.log('üë• Yeni m√º≈üteri ekleniyor:', musteri.id, musteri.ad);
        
        // Generate ID if not provided
        if (!musteri.id) {
            musteri.id = 'MST' + Date.now();
        }
        
        // Validate required fields
        if (!musteri.ad) {
            return res.status(400).json({
                success: false,
                message: 'M√º≈üteri adƒ± zorunludur',
                timestamp: new Date().toISOString()
            });
        }
        
        // Ensure proper data types and handle null/undefined values
        const id = musteri.id || '';
        const ad = musteri.ad || '';
        const telefon = musteri.telefon || '';
        const adres = musteri.adres || '';
        const bakiye = parseFloat(musteri.bakiye) || 0;
        
        const result = db.prepare(`
            INSERT OR REPLACE INTO musteriler (id, ad, telefon, adres, bakiye, updated_at)
            VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
        `).run(id, ad, telefon, adres, bakiye);
        
        // Real-time sync to all clients
        io.to('dataSync').emit('dataUpdated', {
            type: 'musteri-add',
            data: musteri,
            timestamp: new Date().toISOString()
        });
        
        res.status(201).json({ 
            success: true, 
            message: 'M√º≈üteri ba≈üarƒ±yla eklendi', 
            data: musteri,
            timestamp: new Date().toISOString()
        });
        
    } catch (error) {
        console.error('‚ùå M√º≈üteri eklenirken hata:', error);
        res.status(500).json({ 
            success: false, 
            message: 'M√º≈üteri eklenirken hata', 
            error: error.message,
            timestamp: new Date().toISOString()
        });
    }
});

// POST /api/backup-email - Manuel email backup
app.post('/api/backup-email', async (req, res) => {
    try {
        console.log('üìß Manuel email backup ba≈ülatƒ±lƒ±yor...');
        
        await sendDailyBackup();
        
        res.json({
            success: true,
            message: 'Email backup ba≈üarƒ±yla g√∂nderildi',
            timestamp: new Date().toISOString()
        });
        
    } catch (error) {
        console.error('‚ùå Manuel email backup hatasƒ±:', error);
        res.status(500).json({
            success: false,
            message: 'Email backup g√∂nderilemedi',
            error: error.message,
            timestamp: new Date().toISOString()
        });
    }
});

// Health check endpoint
app.get('/health', (req, res) => {
    res.json({
        status: 'OK',
        timestamp: new Date().toISOString(),
        uptime: process.uptime(),
        database: db !== null ? 'connected' : 'disconnected'
    });
});

// API documentation endpoint
app.get('/api/docs', (req, res) => {
    res.json({
        success: true,
        message: 'API Documentation',
        endpoints: {
            'GET /api/test': 'API test ve database durumu',
            'GET /api/tum-veriler': 'T√ºm verileri getir',
            'POST /api/tum-veriler': 'T√ºm verileri kaydet',
            'POST /api/stok-ekle': '√úr√ºn ekle',
            'POST /api/satis-ekle': 'Satƒ±≈ü kaydet',
            'POST /api/musteri-ekle': 'M√º≈üteri ekle',
            'GET /api/database-status': 'Database durumu',
            'GET /health': 'Sistem saƒülƒ±ƒüƒ±',
            'GET /': 'Ana sayfa',
            'GET /test': 'Test sayfasƒ±'
        },
        websocket: {
            'requestData': 'Veri isteƒüi g√∂nder',
            'dataUpdate': 'Veri g√ºncelleme g√∂nder',
            'connected': 'Baƒülantƒ± onayƒ± al',
            'dataResponse': 'Veri yanƒ±tƒ± al',
            'updateResponse': 'G√ºncelleme yanƒ±tƒ± al'
        },
        timestamp: new Date().toISOString()
    });
});

// Stock update endpoint
app.put('/api/stok-guncelle', async (req, res) => {
    try {
        if (!db) {
            return res.status(500).json({
                success: false,
                message: 'Database connection not available'
            });
        }
        
        const { barkod, ad, miktar, alisFiyati, satisFiyati, kategori, aciklama } = req.body;
        
        if (!barkod) {
            return res.status(400).json({
                success: false,
                message: 'Barkod gerekli'
            });
        }
        
        const updateStock = db.prepare(`
            UPDATE stok SET 
                ad = ?, miktar = ?, alisFiyati = ?, satisFiyati = ?, 
                kategori = ?, aciklama = ?, updated_at = CURRENT_TIMESTAMP
            WHERE barkod = ?
        `);
        
        const result = updateStock.run(
            ad || '',
            parseInt(miktar) || 0,
            parseFloat(alisFiyati) || 0,
            parseFloat(satisFiyati) || 0,
            kategori || '',
            aciklama || '',
            barkod
        );
        
        if (result.changes === 0) {
            return res.status(404).json({
                success: false,
                message: '√úr√ºn bulunamadƒ±'
            });
        }
        
        res.json({
            success: true,
            message: '√úr√ºn ba≈üarƒ±yla g√ºncellendi'
        });
    } catch (error) {
        console.error('‚ùå Error updating stock:', error);
        res.status(500).json({
            success: false,
            message: '√úr√ºn g√ºncellenirken hata olu≈ütu',
            error: error.message
        });
    }
});

// Stock delete endpoint
app.delete('/api/stok-sil/:barkod', async (req, res) => {
    try {
        if (!db) {
            return res.status(500).json({
                success: false,
                message: 'Database connection not available'
            });
        }
        
        const { barkod } = req.params;
        
        if (!barkod) {
            return res.status(400).json({
                success: false,
                message: 'Barkod gerekli'
            });
        }
        
        const deleteStock = db.prepare('DELETE FROM stok WHERE barkod = ?');
        const result = deleteStock.run(barkod);
        
        if (result.changes === 0) {
            return res.status(404).json({
                success: false,
                message: '√úr√ºn bulunamadƒ±'
            });
        }
        
        res.json({
            success: true,
            message: '√úr√ºn ba≈üarƒ±yla silindi'
        });
    } catch (error) {
        console.error('‚ùå Error deleting stock:', error);
        res.status(500).json({
            success: false,
            message: '√úr√ºn silinirken hata olu≈ütu',
            error: error.message
        });
    }
});

// Legacy endpoints for backward compatibility
app.get('/urunler', async (req, res) => {
    try {
        if (!db) {
            return res.status(500).json({
                success: false,
                message: 'Database connection not available'
            });
        }
        
        const rows = db.prepare('SELECT * FROM stok').all();
        let stokData = {};
        rows.forEach(row => { 
            stokData[row.barkod] = {
                barkod: row.barkod,
                ad: row.ad,
                miktar: row.miktar,
                alisFiyati: row.alisFiyati,
                satisFiyati: row.satisFiyati,
                kategori: row.kategori,
                aciklama: row.aciklama,
                eklenmeTarihi: row.created_at
            };
        });
        
        res.json({
            success: true,
            data: stokData,
            message: '√úr√ºnler ba≈üarƒ±yla getirildi'
        });
    } catch (error) {
        console.error('‚ùå Error getting products:', error);
        res.status(500).json({
            success: false,
            message: '√úr√ºnler okunurken hata olu≈ütu',
            error: error.message
        });
    }
});

app.post('/urunler', async (req, res) => {
    try {
        if (!db) {
            return res.status(500).json({
                success: false,
                message: 'Database connection not available'
            });
        }
        
        const { stokListesi } = req.body;
        if (!stokListesi || typeof stokListesi !== 'object') {
            return res.status(400).json({
                success: false,
                message: 'Ge√ßersiz veri formatƒ±. stokListesi objesi bekleniyor.'
            });
        }
        
        const transaction = db.transaction(() => {
            // Clear existing stock
            db.prepare('DELETE FROM stok').run();
            
            // Insert new stock data
            const insertStok = db.prepare(`
                INSERT INTO stok (barkod, ad, marka, miktar, alisFiyati, satisFiyati, kategori, aciklama, varyant_id) 
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            `);
            
            let insertedCount = 0;
            for (const key in stokListesi) {
                const urun = stokListesi[key];
                try {
                    // Ensure we use the actual barcode from the product object
                    const barkod = urun.barkod || key;
                    
                    insertStok.run(
                        barkod,
                        urun.ad || '',
                        urun.marka || '',
                        parseInt(urun.miktar) || 0,
                        parseFloat(urun.alisFiyati) || 0,
                        parseFloat(urun.satisFiyati) || 0,
                        urun.kategori || '',
                        urun.aciklama || '',
                        urun.varyant_id || ''
                    );
                    insertedCount++;
                } catch (e) {
                    console.warn(`‚ö†Ô∏è Error inserting product ${key}:`, e.message);
                }
            }
            return insertedCount;
        });
        
        const count = transaction();
        
        res.json({
            success: true,
            message: '√úr√ºnler ba≈üarƒ±yla kaydedildi',
            count: count
        });
    } catch (error) {
        console.error('‚ùå Error saving products:', error);
        res.status(500).json({
            success: false,
            message: '√úr√ºnler kaydedilirken hata olu≈ütu',
            error: error.message
        });
    }
});

// Yeni API endpoint'leri
app.get('/api/categories', async (req, res) => {
    try {
        const categories = db.prepare('SELECT DISTINCT kategori FROM stok WHERE kategori IS NOT NULL AND kategori != "" ORDER BY kategori').all();
        res.json({
            success: true,
            data: categories.map(c => c.kategori)
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

app.post('/api/bulk-update', async (req, res) => {
    try {
        const { operation, products, value } = req.body;
        
        if (!operation || !products || products.length === 0) {
            return res.status(400).json({
                success: false,
                message: 'Ge√ßersiz parametreler'
            });
        }
        
        const transaction = db.transaction(() => {
            let updatedCount = 0;
            
            products.forEach(barkod => {
                try {
                    switch(operation) {
                        case 'price_update':
                            db.prepare('UPDATE stok SET satisFiyati = ? WHERE barkod = ?').run(value, barkod);
                            break;
                        case 'stock_update':
                            db.prepare('UPDATE stok SET miktar = ? WHERE barkod = ?').run(value, barkod);
                            break;
                        case 'category_update':
                            db.prepare('UPDATE stok SET kategori = ? WHERE barkod = ?').run(value, barkod);
                            break;
                    }
                    updatedCount++;
                } catch (e) {
                    console.warn(`‚ö†Ô∏è Error updating product ${barkod}:`, e.message);
                }
            });
            
            return updatedCount;
        });
        
        const count = transaction();
        
        res.json({
            success: true,
            message: `${count} √ºr√ºn g√ºncellendi`,
            count: count
        });
        
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// Test sayfasƒ±
app.get('/test', (req, res) => {
    res.sendFile(path.join(__dirname, 'test.html'));
});

// Ana sayfa i√ßin HTML dosyasƒ±nƒ± serve et
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'try.html'));
});

// Start server
server.listen(PORT, () => {
    console.log(`üöÄ Server running on port ${PORT}`);
    console.log(`üìä Database: ${dbPath}`);
    console.log(`üîó WebSocket: ws://localhost:${PORT}`);
    console.log(`üåê HTTP: http://localhost:${PORT}`);
    console.log(`üß™ Test: http://localhost:${PORT}/test`);
    console.log(`üìã API Docs: http://localhost:${PORT}/api/test`);
});

// Graceful shutdown
process.on('SIGINT', () => {
    console.log('\nüõë Shutting down server...');
    if (db) {
        db.close();
        console.log('‚úÖ Database connection closed');
    }
    server.close(() => {
        console.log('‚úÖ Server stopped');
        process.exit(0);
    });
});

process.on('SIGTERM', () => {
    console.log('\nüõë Shutting down server...');
    if (db) {
        db.close();
        console.log('‚úÖ Database connection closed');
    }
    server.close(() => {
        console.log('‚úÖ Server stopped');
        process.exit(0);
    });
});